# <<MySQL实战45讲>>笔记

[toc]

## 1 MySQL的逻辑架构图

<img src="https://i.loli.net/2020/07/16/snMdaHVjG6iPX47.png" alt="image-20200716155234593" style="zoom:50%;" />

**在Server层主要可以分为一下的内容：连接器，分析器，优化器，执行器，查询缓存。**

**连接器：**负责跟客户端建立连接、获取权限、维持和管理连接

**分析器：**负责词法，语法分析，同时根据分析结果，判断输入的SQL语句是否满足MYSQL语法。

**优化器：**当有多个索引的时候，负责决定使用哪一个索引，又或者在多表查询的时候决定各表连接的顺序，也就是说优化器选择一个语句的执行方案。

**执行器：**负责一个对表的权限的校验，执行一个具体计划，调用对应存储引擎的一个接口并进行处理。

**查询缓存：**对于一个查询语句，建立了一个连接之后，会先查询缓存，如果有结果就可以直接返回了。

## 2 MYSQL的redo log和binlog

MYSQL为了可以还原到某一时间点的数据库的内容，存在着多个日志系统。

**比如说redo log和binlog**，两者既有相似的地方也有不同的地方

**redo log**

作用：
　　1. 确保事务的持久性。
　　2. 防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

**binlog**

作用：
　　1. 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
　　2. 用于数据库的基于时间点的还原。

**区别**

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”，可以简单的理解为sql语句，但不单单是sql语句。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
4. **redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。**
5. 恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog



由于存在多个不同的日志，那么为了保证日志的一致性，就必须要有一个保存日志的策略。

一般**为了保证一致性**，采用的是两阶段提交的办法。

```
1 prepare阶段 2 写binlog 3 commit

当在2之前崩溃时
重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。 一致
当在3之前崩溃
重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致

```
**采用两阶段提交的原因**

> 1. **先写redo log后写binlog**。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
>    但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
>    然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
> 2. **先写binlog后写redo log**。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。
> 3. 因此，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

## 3 事务的隔离级别

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 4 事务隔离级别的实现

需要知道的是，在MySQL中，实际上每条记录在更新的时候都会同时**记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

其中RC和RR两种隔离级别主要是依赖于MVCC来进行实现的。

## 5 关于长事务

建议尽量不要使用长事务。

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

**如何避免长事务对业务的影响？**

**首先，从应用开发端来看：**

1. **确认是否使用了set autocommit=0**。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。
2. **确认是否有不必要的只读事务**。有些框架会习惯不管什么语句先用begin/commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来**控制每个语句执行的最长时间**，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）

**其次，从数据库端来看：**

1. 监控 information_schema.Innodb_trx表，**设置长事务阈值**，超过就报警/或者kill；
2. Percona的pt-kill这个工具不错，推荐使用；
3. 在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；
4. 如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。

## 6 索引的数据结构

为了提高查询的效率，有很多优秀的数据结构可以使用。比如说哈希表，有序数组，搜索树等。但是，不同数据结构有不同的特点，并不是都适合索引的建设。

**哈希表**

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

**优点**：

等值查询速度快，速度接近O（1）

**缺点**：

1. 存在哈希冲突的问题，解决办法就是对于同一个哈希key，使用链表保存所有的数据
2. 区间查询效率低，需要一个一个单点查询

**有序数组**

有序数组就是一个排好序的数组了

**优点**：

单点查询和区间查询的效率优秀，可以利用二分到达O（log）的复杂度

**缺点**：

插入数据效率低，为了保证有序，每次插入需要挪动大量的数据 

**搜索树**

二叉搜索树，正常情况下插入和查询的性能不错，都是O（log）的时间复杂度，但是在极端情况下，二叉树会退化成一条单链，时间复杂度退化

平衡二叉树和红黑树，解决了二叉搜索树退化的问题，其中avl树查找性能优于rbtree，rbtree的删除和插入性能由于avl，但是这两者由于是二叉树，所以相同数据下和多叉树相比，树的高度更高，这也就意味着需要更多的磁盘IO次数，需要消耗更多的时间，因此也不是特别适合。而且二叉树结构很难利用数据局部性原则，磁盘预热的效果不明显。

B树，平衡多叉树，改进了二叉树的每个节点最多只有2个子节点的问题，现在每个节点可以有多个子节点，这样的好处在于可以减少树的高度，减少磁盘的IO次数，加快查询的速度。比较适合用于磁盘文件组织、数据索引和数据库索引中。

B+树，改进版的B树，使得B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引。

**原因在于一下三点：**

1. B+树的非叶节点不保存任何具体的信息，B树则会保存，这使得每个节点保存的信息B+树会更多。

2. B+树更适合范围查询。因为B+树在同一层的节点中不仅是有序的，而且还通过双向链表连通着，这使得B+树只要找到了一个数据地下限就可以轻松的遍历出所要查询的区间信息。而B树就需要用中序遍历的方法扫库，比较麻烦。

3. B+树拥有更稳定的查询效率，B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。

   

 **在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引。**

## 7 索引的其他概念

**覆盖索引**：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
**最左前缀**：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符
**联合索引**：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
**索引下推**：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

**关于重建索引**

原因：索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

**重建普通索引**

```sql
alter table T drop index k;
alter table T add index(k);
//对于普通索引而言，合理
```



**重建主键索引**

```sql
alter table T drop primary key;
alter table T add primary key(id);
//不合理，不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ：
//alter table T engine=InnoDB。
```



**建立索引的一些标准**

1. 选择基数大的列建立索引
2. 为经常需要排序、分组和联合操作的字段建立索引
3. 尽量限制索引的数量
4. 索引列尽量不要参与计算
5. 为了尽可能少的让`聚簇索引`发生页面分裂和记录移位的情况，建议让主键拥有`AUTO_INCREMENT`属性。
6. 尽量使用覆盖索引
7. 利用最左前缀原则进行优化
8. 索引的字段类型要尽量的小

## 8 MRR

MRR 的全称是 Multi-Range Read Optimization，是优化器将随机 IO 转化为顺序 IO 以降低查询过程中 IO 开销的一种手段，基于辅助/第二索引的查询，减少缓冲池中页被替换的次数。

通俗的来说，是在取出主键后，回表之前，会在对所有获取到的主键排序，这样子就使得回表的随机IO替换为了顺序IO，加快了访问的速度。

- **不使用MRR**之前(MySQL5.6之前)，先根据where条件中的辅助索引获取辅助索引与主键的集合，再通过主键来获取对应的值。辅助索引获取的主键来访问表中的数据会导致随机的IO(辅助索引的存储顺序并非与主键的顺序一致)，随机主键不在同一个page里时会导致多次IO和随机读。
- **使用MRR优化**(MySQL5.6之后)，先根据where条件中的辅助索引获取辅助索引与主键的集合，再将结果集放在buffer(read_rnd_buffer_size 直到buffer满了)，然后对结果集按照pk_column排序，得到有序的结果集rest_sort。最后利用已经排序过的结果集，访问表中的数据，此时是顺序IO。即MySQL 将根据辅助索引获取的结果集根据主键进行排序，将无序化为有序，可以用主键顺序访问基表，将随机读转化为顺序读，多页数据记录可一次性读入或根据此次的主键范围分次读入，减少IO操作，提高查询效率。

## 9 全局锁和表级锁

**全局锁**

全局锁会对整个数据库实例加锁，一般只会在做全库逻辑备份的时候才会用到，可以采用` Flush tables with read lock`这一个命令实现全局锁的功能。一旦使用，像数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句这些语句都会被阻塞。	

在使用Innodb为引擎的库中，可以使用官方自带的逻辑备份工具是mysqldump。。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。

**表级锁**

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

**表锁的语法是 lock tables … read/write。**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。

**另一类表级的锁是MDL（metadata lock)。**

MDL不需要显式使用，在访问一个表的时候会被自动加上。

MDL用于解决或者保证DDL操作与DML操作之间的一致性。

当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

**MDL锁可能带来的问题**

<img src="https://i.loli.net/2020/07/17/DJcComqtyLknMYV.png" alt="image-20200717191509539" style="zoom:50%;" />

我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。

之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。

如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。

**如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。**

事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会**等到整个事务提交后再释放。**

**如何安全的给表加字段？**

首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

## 10 “N叉树”的N值在MySQL中是可以被人工调整吗？

N取决于页大小（page）和单个索引大小（index）。

$$N=page/index$$

N叉树中非叶子节点存放的是索引信息，索引包含Key和Point指针。Point指针固定为6个字节，假如Key为10个字节，那么单个索引就是16个字节。如果B+树中页大小为16K，那么一个页就可以存储1024个索引，此时N就等于1024。我们通过改变Key的大小，就可以改变N的值

## 11 行锁

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

因此，基于两阶段所协议，事务中语句的顺序可以进行一定的优化。**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**

同时，因为行锁的这个原因，多个事务同时运行的时候是有概率出现死锁的情况的。有两种策略可以处理死锁的情况。

- 一种策略是，直接进入**等待**，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 另一种策略是，发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测。



## 12 如何更新热点行的数据，减少冲突

1. 在服务端降低并发度，可以通过使用中间件的方式来处理

2. 拆分热点行为多行，比如一个银行账户拆分为多个，这样可以减少锁冲突（分库分表）

   

## 13 MVCC

### 13.1 事务的启动时机

- begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动,一致性视图是在执行第一个快照读语句时创建的。
- 如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

### 13.2 行锁的时机

对于select语句，默认不加锁，但是可以人为加共享锁和排他锁

对于更新语句，默认会添加排他锁

### 13.3 快照读和当前读

-  **当前读**:

　　select...lock in share mode (共享读锁)
　　select...for update
　　update , delete , insert

 		当前读的实现方式：next-key锁(行记录锁+Gap间隙锁)

​		**读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录**

-   **快照读**

　　单纯的select操作，**不包括**上述 select ... lock in share mode, select ... for update。　　　　

　　Read Committed隔离级别：每次select都生成一个快照读。

　　Read Repeatable隔离级别：**开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。**

​		快照读的实现方式：undolog和多版本并发控制MVCC

​	**读取的是记录数据的可见版本**（可能是过期的数据），不用加锁

### 13.4 MVCC的原理

MVCC中文名称多版本并发控制，是四大隔离级别中RC和RR的实现方式。

MVCC主要通过版本链的方式来实现功能，对于每一行数据，MYSQL记录两列隐藏列，trx_id用于记录修改该行的事务ID，按照申请时间递增，同时还记录roll_pointer列用于指向该行记录上一个版本所在位置。中间同时会记录undolog用于数据的回滚。

每次在一个事务中开启一个视图的时候，会构建一个数组m_ids，用来保存当前启动了但未提交的事务的ID。同时记录m_ids中最小的事务ID为低水位，记录当前系统里面已经创建过的事务ID的最大值加1为高水位。

<img src="https://i.loli.net/2020/07/18/ETMfIljZn4g8Ka9.png" alt="image-20200718141040440" style="zoom:67%;" />

那么对于一条数据在某个视图下可见的数据就遵守一下的规则。

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
   a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；
   b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

说明一下，落在绿色的事务id，说明一定已经提交了。在红色部分的事务id，在生成当前视图的时候是一定还没有启动事务。

在黄色部分的事务id都是启动了的，但是不能简单的判断是否已经提交。需要通过m_ids数组来确定是否提交。由于m_ids中的都是**启动了但未提交的事务的ID**，所以就可以理解在数组中的数据版本都是不可见的了。

需要注意的一点是：在事务中普通的select语句的确是遵循以上的原则，只能读取到当前视图中的数据，但是对于insert，delete，update等语句，他们所用到的数据都是最新的，**更新数据都是先读后写的**，不受视图的控制，**但是会受到锁的限制**。对于select语句，如果人为的加锁，也是使用当前读。

```
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

