## JVM虚拟机相关

[toc]

## JVM运行时数据区域

根据 JVM 规范，JVM 内存共分为**虚拟机栈、堆、方法区、程序计数器、本地方法栈**五个部分。

![](https://user-gold-cdn.xitu.io/2018/10/15/166786b5cf6d7f95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 虚拟机栈

   每个线程有一个私有的栈，随着线程的创建而创建。栈里面存放着一种叫做“栈帧”的东西，每个方法在执行的时候会创建一个栈帧，**存储了局部变量表(基本数据类型和对象引用)，操作数栈，动态连接，方法出口等信息。** 每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。 通常所说的栈，一般是指虚拟机栈中的局部变量表部分。局部变量表所需的内存在编译期间完成分配。

   会抛出StackOverflowError和OutOfMemoryError。

2. 本地方法栈

   和虚拟机栈类似，主要为虚拟机使用到的**Native**方法服务。

   会抛出StackOverflowError和OutOfMemoryError。

3. 程序计数器

   JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是JVM方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器为空。 

   不会抛出StackOverflowError和OutOfMemoryError。

4. 堆

   堆内存是JVM所有线程共享的部分，在虚拟机启动的时候就已经创建。 和程序开发密切相关，应用系统**对象都保存在Java堆中**。所有的对象和数组都在堆上进行分配。这部分空间可通过GC进行回收。

   会抛出OutOfMemoryError。

5. 方法区

   方法区也是所有线程共享的。主要用于存储**类的信息、常量池、方法数据、方法代码**等。这个区域的内存回收目标主要针对常量池的回收和对类型的卸载。
   当方法区无法满足内存分配需求时，则抛出OutOfMemoryError异常。

   可以这么理解：一个对象的引用是位于栈区，而对象的实例是放在堆区。

## 常量池

<https://www.jianshu.com/p/c7f47de2ee80>

有以下几类

1. 全局字符串池
2. class文件常量池
3. 运行时常量池

## 编译和加载的区别

参考博客：<https://zhuanlan.zhihu.com/p/33509426>

编译指的是我们写的.java 文件通过调用 -javac 命令生成.class 的字节码文件。

而加载指的是将**class字节码文件**从各个来源通过**类加载器**装载入内存中。

- **字节码来源**。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
- **类加载器**。一般包括**启动类加载器**，**扩展类加载器**，**应用类加载器**，以及用户的**自定义类加载器**。

### 类加载流程

- 加载

  将**class字节码文件**从各个来源通过**类加载器**装载入内存中。

- 链接

  - 验证

    主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。

  - 准备

    主要是为类变量（也就是静态变量）分配内存，并且赋予**初值（对于基本类型的数据是0，对象则是null）**。

  - 解析

    将**常量池**内的符号引用替换为直接引用的过程。

    - **符号引用**。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息，可以理解为一个变量。
    - **直接引用**。可以理解为一个内存地址，或者一个偏移量。

- 初始化

  对类变量进行初始化

  ### 类加载机制

  1. **全盘负责**：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也由该类加载器负责载入，除非显示使用另一个类加载器来载入。
  2. **双亲委派**：先让父加载器试图加载该Class，**是个递归的过程**，只有在父加载器无法加载时该类加载器才会尝试从自己的类路径中加载该类。
  3. **缓存机制**：缓存机制会将已经加载的class缓存起来，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存中不存在该Class时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存中。这就是为什么更改了class后，需要重启JVM才生效的原因。

**关于双亲委派的具流程**

当我们要加载一个应用程序 `classpath` 下的自定义类时，AppClassLoader 会首先查看自己是否已经加载过这个类，如果已经加载过则直接返回类的实例，否则将加载任务委托给自己的父加载器 ExtClassLoader。同样，ExtClassLoader 也会先查看自己是否已经加载过这个类，如果已经加载过则直接返回类的实例，否则将加载任务委托给自己的父加载器 BootStrapClassLoader。

BootStrapClassLoader 收到类加载任务时，会首先检查自己是否已经加载过这个类，如果已经加载则直接返回类的实例，否则在自己负责的加载路径下搜索这个类并尝试加载。如果找到了这个类，则执行加载任务并返回类实例，否则将加载任务交给 ExtClassLoader 去执行。

ExtClassLoader 同样也在自己负责的加载路径下搜索这个类并尝试加载。如果找到了这个类，则执行加载任务并返回类实例，否则将加载任务交给 AppClassLoader 去执行。

由于自己的父加载器 ExtClassLoader 和 BootStrapClassLoader 都没能成功加载到这个类，所以最后由 AppClassLoader 来尝试加载。同样，AppClassLoader 会在 `classpath` 下所有的类库中查找这个类并尝试加载。如果最后还是没有找到这个类，则抛出 `ClassNotFoundException` 异常。

## 内存模型

**首先说明一点,在前面讲述的运行时数据区,只是JVM的规范,并不是具体的实现。**

在jdk1.7中,JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为**年轻代**和**老年代**，而非堆内存则为**永久代**。

年轻代又会分为**Eden**和**Survivor**区。Survivor也会分为**FromPlace**和**ToPlace**，Eden，FromPlace和ToPlace的默认占比为 **8:1:1**。

而在jdk1.8中，移除了永久代，取而代之的是元空间。

### 关于元空间和永久代之间的区别和联系

上面提到过，方法区只是JVM的规范，而具体实现则是依赖于永久代（而且永久代只是HotSpot实现的，其他类型的虚拟机并没有这个）。而元空间则是对方法区的另外一种实现。

在移除了永久代之后，
原来的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）
永久代中的 interned Strings 和 class static variables 转移到了 Java heap
永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

### 为什么要将永久代替换为元空间

1. 移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。

2. 由于永久代内存经常不够用或发生内存泄露（比如spring大量创建的对象），而使用元空间， class metadata是放在本地内存中的，也就没有了内存不足的问题。

### 如何保证内存分配的时候是线程安全的

参考博文：<https://juejin.im/post/5e66f59f6fb9a07cde64e6da>

一种方法是使用TLAB技术（Thread Local Allocation Buffer），即线程本地分配缓存区。

首先说明，TLAB并不是JVM的规范,只是HotSpot虚拟机的一个优化方案，也就是在别的虚拟机上不一定有这个技术。

#### 什么是TLAB

TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。

#### 注意事项

TLAB的线程共享只是指在内存分配上是独享的，但是在读取或者是内存回收的时候是共享的。

<img src="https://user-gold-cdn.xitu.io/2020/3/10/170c22f885ad61df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:70%;" />

#### TLAB带来的问题

因为TLAB通常不会很大，所以就会有对象无法分配在TLAB中的问题。

那么这就有2种解决方法

1. 如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。
2. 如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则废弃当前TLAB，重新申请TLAB空间再次进行内存分配。

以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是TLAB只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。

如果采用方案2，也有可能存在频繁废弃TLAB，频繁申请TLAB的情况，而我们知道，虽然在TLAB上分配内存是线程独享的，但是TLAB内存自己从堆中划分出来的过程确实可能存在冲突的，所以，TLAB的分配过程其实也是需要并发控制的。而频繁的TLAB分配就失去了使用TLAB的意义。



### 内存分配

对象的内存分配主要是在堆上分配。对象优先在新生代的 Eden 区上，少数情况也会直接分配到老年代中，分配规则是可以通过配置参数进行调整。我们接下来看一下通常情况下内存的分配规则。

**1）对象优先在 Eden 分配**

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区空间不足时触发 Minor GC。

**2）大对象直接进入老年代**

所谓大对象是指需要大量连续内存空间的对象，比如很长的字符串或数组。

虚拟机提供了 -XX:PretenureSizeThreshold 参数，令大于该参数值的对象直接进入老年代。避免在 Eden 区和两个 Survivor 区之间发生大量的内存复制。

**3）长期存活的对象将进入老年代**

在内存回收时，虚拟机需要识别哪些对象应该放在新生代，哪些对象应该放在老年代。虚拟机给每个对象定义了一个对象年龄计数器。对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能够被 Survivor 容纳，则被移动到 Survivor 区，且对象年龄设为1。对象在 Survivor 区每经过一次 Minor GC， 年龄加1。当年龄增长到一定程度（默认为15岁），将会被放到老年代。

虚拟机提供了 -XX:MaxTenuringThreshold 参数，设置对象进入老年代的年龄阈值。

**4）动态对象年龄判定**

如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

**5）空间分配担保**

在前面我们讲到，新生代采用的是复制算法。如 HotSpot 虚拟机中，将新生代分为 Eden 区和两个 Survivor 区，默认比例是8:1。每次 Minor GC 时会讲 Eden 区和 一个 Survivor 区中存活的对象拷贝到另一个 Survivor 区。那么可能存在这么一种情况，就是另一Survivor 区的空间不足一容纳 Eden 区和 Survivor 区中存活的对象，这个时候该怎么办？这里就是我们要说的空间分配担保，如果上面发生了上面说的那种情况，那么在 Eden 区和 Survivor 区存活的对象将直接进入老年代，即老年代为 Survivor 区进行担保。

而老年代采用的是标记-整理算法，无需其他空间担保。当老年代空间不足时，触发一次 Full GC。

现在来看什么时候进行垃圾回收就比较清晰了，当新生代空间不足以为对象分配空间时，触发一次 Minor GC，当老年代空间不足以为对象分配空间时，触发一次 Full GC。

### 垃圾回收

安利博客<https://zhuanlan.zhihu.com/p/82936943>

#### 哪些地方会执行垃圾回收

1. **线程私有内存区域（程序计数器、虚拟机栈、本地方法栈）**会随着线程的结束而释放。因此**无需对该区域进行垃圾回收**。
2. **线程共享内存区域（方法区和Java堆）**需要分配的内存大小只有在运行期才知道，因此是需要垃圾回收的。

对于堆而言，一般回收的都是对象实例，一旦这个对象实例不再被引用，那么它就会被垃圾回收。

而对于方法区而言，一般回收的是废弃常量和无用的类。

对于废弃常量，比如说常量池种有一个字符串“abc”，当没有任何一个String对象引用这个常量时，那么"abc"也许就会被回收。

对于无用的类，回收的条件比较苛刻，需要满足下面的条件：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

2. 加载该类的ClassLoader已经被回收。

3. 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

当然，对于这种无用的类，回收是不强制的。

但是在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

#### 哪些对象需要被回收？

一般指的是不会再被调用的实例需要被回收，对于如何判断，一般有下面2种方法。

1. **引用计数算法**

为每个对象添加一个引用计数器，每当有一个地方引用它时，计数器的值加1，当引用失效时，计数器的值减1。当计数器的值为0时表示该对象没有被引用。

缺点：对于循环嵌套的两个对象，是无效的。

```java
public class ReferenceCountingGC {
    public Object instance = null;
    public static void testGC () {
        ReferenceCountingGC objA = new ReferenceCountingGC();//r1 =0 + 1
        ReferenceCountingGC objB = new ReferenceCountingGC();//r2 =0 + 1

        objA.instance = objB;//r1 = 1 + 1
        objB.instance = objA;//r2 = 1 + 1   

        objA = null;//r1 = 2 - 1  
        objB = null;//r2 = 2 - 1
		/*
		也就是说，很明显，两个ReferenceCountingGC应该已经是无效了，但是如果采用引用计数法，那么引用计数器还是1，也就是不会清除
		*/
        System.gc();

    }
}
```



2. **可达性分析算法**

针对引用计数法的缺点，又有了一种新的方法。

该算法的基本思想是：通过一系列被称为”GC Roots“的对象作为起始点，开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何的引用链时，则证明此对象是不可用的。这个算法也就跟DFS很像。

##### 什么是GCRoots

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象

2. 本地方法栈中JNI（native方法）引用的对象

3. 方法区中类静态属性引用的对象

4. 方法区中常量引用的对象

以上这四类，是可以作为GCRoots。

可以看这张图理解一下，很明显object5，object6，object7会被回收

<img src="https://pic1.zhimg.com/80/v2-4d4e0ed6f2096c84cfcb69bc3177ff28_720w.jpg" alt="img" style="zoom: 80%;" />



#### 垃圾回收算法

主要有4种，分别是**标记-清除算法**，**复制算法**，**标记-整理算法**，**分代收集算法**

##### 标记-清除算法

这个算法分为两步，标记和清除。

标记的过程一般采用上面的**可达性分析算法**，标记完了之后，只需要把所标记的内存块清空即可。

这个算法的问题在于容易产生内存碎片。

<img src="https://user-gold-cdn.xitu.io/2019/4/27/16a5ea4eb93ecd71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="标记-清除算法" style="zoom:50%;" />

##### **复制算法**

这个算法是先把内存一分为二，然后每次只使用其中的一块内存，当一块满了之后，就会启动算法，将所有活对象移到另外一块中，然后就把刚才使用的全部清空，那么下次就使用有活对象的那块。这样子就解决了内存碎片的问题，但缺点是会浪费一部分空间。

<img src="https://user-gold-cdn.xitu.io/2019/4/27/16a5ea4eb9263e41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="复制算法" style="zoom:50%;" />

##### 标记-整理算法

同样需要先标记，然后不是清除垃圾，而是把所有活得对象都往前移，按内存地址排序，然后把末尾的全部清空。

<img src="https://user-gold-cdn.xitu.io/2019/4/27/16a5ea4eb9c8634b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="标记-整理"  />

##### 分代收集算法

一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。

##### 前面3种算法的效率

|          | 标记-清除算法      | 标记-整理算法    | 复制算法                              |
| -------- | ------------------ | ---------------- | ------------------------------------- |
| 速度     | 中等               | 最慢             | 最快                                  |
| 空间开销 | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍大小（不堆积碎片） |
| 移动对象 | 否                 | 是               | 是                                    |

##### **关于复制算法比标记整理-算法快的一点解释**

虽然compactiont与copying都涉及移动对象，但取决于具体算法，compact可能要先计算一次对象的目标地址，然后修正指针，然后再移动对象；copying则可以把这几件事情合为一体来做，所以可以快一些。

#### 垃圾收集器//以后再补更深层次的知识

**新生代的垃圾收集器**

- Serial
- ParNew
- Parallel Scavenge

**老年代的垃圾收集器**

- Serial Old
- CMS（Concurrent Mark Sweep）
- Parallel Old

**新生代和老年代均可用**：**G1垃圾收集器**

![img](https://pic2.zhimg.com/80/v2-da5b51830ab9ebac78b42a29a76fbb35_720w.jpg)

| 收集器             | 串行/并行/并发 | 新生代/老年代 | 算法          | 目标         | 场景                                      |
| ------------------ | -------------- | ------------- | ------------- | ------------ | ----------------------------------------- |
| serial             | 串行           | 新生代        | 复制          | 响应速度优先 | 单CPU环境下的client模式                   |
| serial Old         | 串行           | 老年代        | 标记整理      | 响应速度优先 | 单CPU环境下的client模式，CMS的后备预案    |
| ParNew             | 并行           | 新生代        | 复制          | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| Parallel Scaveenge | 并行           | 新生代        | 复制          | 吞吐量优先   | 在后台运行而不需要太多交互的任务          |
| Parallel Old       | 并行           | 老年代        | 标记整理      | 吞吐量优先   | 在后台运行而不需要太多交互的任务          |
| CMS                | 并发           | 老年代        | 标记清理      | 响应速度优先 | 基中在互联网站或B/S系统服务端上的java应用 |
| G1                 | 并发           | both          | 复制/标记清理 | 响应速度优先 | 面向服务端应用，将来替换CMS               |

##### 关于CMS收集器

**与 Parallel Old 收集器的区别：**

CMS 收集器目标是获取最短回收停顿时间。

**处理过程：**

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

![img](https://pic2.zhimg.com/80/v2-4884f12eacb027d6ab17a2d4fbfdb3f1_720w.jpg)

1. 第一次标记，仅仅是标记了与 GC Roots 直接关联的对象。且会 stop the world
2. 第二次标记，将第一次标记的对象进行追溯。这个过程不会 stop the world，而是与用户线程并发执行的，所以可能会产生这样两个问题，**一是可能有些被标记的对象是被引用了的**，**二是可能又产生了一些新的垃圾**。针对于“可能有些被标记的对象是被引用了的”情况我们可以通过第三次标记来处理。而对于“可能又产生了一些新的垃圾”的情况我们可以在下次在对其清理，并不影响我本次 GC 的准确性，这个阶段产生的垃圾在教科书中被成为“**浮动垃圾**”。
3. 第三次标记，会修正第二次并发标记过程中因为用户线程执行而导致标记变动的对象。这个阶段耗时比第一次标记要长，但是远比第二次标记耗时要短。

缺点

- 无法处理“浮动垃圾”，只能等到第二次触发GC时进行清理
- CMS既然采用的是标记-清除算法，那么必然会产生大量的空间碎片

## Full GC 触发条件

1. 调用System.gc()，当这个并不绝对，只是建议执行
2. 老年代空间不足
3. 方法区空间不足
4. 在进行空间分配担保的时候，老年代的空间不足以担保的时候，也会发生full GC
5. **通过Minor GC后进入老年代的平均大小大于老年代的可用内存（也就是动态年龄）**
6.  **统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间(也就是4 5,4 5 对应的是两种新生代晋升到老年代的方法,也就是动态年龄和空间分配担保)**

**一般 Full GC 会伴随一次 Minor GC**

## tomcat的类加载器模型

**类加载器主要通过一个类的全限定名在一个规定的目录中去寻找。**

下图是tomcat的一个类加载器模型

<img src="https://i.loli.net/2020/08/03/hCJukAUcrBHiN72.png" alt="image-20200803134608582" style="zoom: 67%;" />

- commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
- catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
- sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
- WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；



tomcat作为一个web容器，里面一般会存在多种多个应用程序，那么一般就会有以下的问题

1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 
2. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。 
3. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 
4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。

> CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用
>
> CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。
>
> 而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。

因此，为了解决上述的问题，使用默认的双亲委派原则是不够的。

对于第一个问题和第三个问题，如果使用默认的双亲委派原则，是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的**全限定类名**，并且只有一份。

第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。

第四个问题要实现jsp的热部署，采用的方法是每次检测到jsp文件被修改，就卸载当前的jsp类加载器，重新创建一个jsp的类加载器，并重新加载jsp文件，这样就可以使用不重启jvm而更新jsp文件的功能。



**【违背双亲委派】：** **tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。例如：如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。**



### 关于上下文类加载器的一个问题的解释

如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围内的用户程序呢？

如果按主流的双亲委派机制，显然无法做到让父类加载器加载的类去访问子类加载器加载的类，但使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作。spring加载类所用的Classloader是通过Thread.currentThread().getContextClassLoader()来获取的，而当线程创建时会默认setContextClassLoader(AppClassLoader)，即线程上下文类加载器被设置为AppClassLoader，spring中始终可以获取到这个AppClassLoader(在Tomcat里就是WebAppClassLoader)子类加载器来加载bean，以后任何一个线程都可以通过getContextClassLoader()获取到WebAppClassLoader来getbean了。

<img src="https://i.loli.net/2020/08/03/OUH8pDbh92icLYX.png" alt="image-20200803140755743" style="zoom:80%;" />

**【Tomcat类加载过程】：**

**tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。具体的加载逻辑位于W`ebAppClassLoaderBase.loadClass()`方法中，这里以文字描述加载一个类过程：**

　　1 使用bootstrap引导类加载器加载

　　2 使用system系统类加载器加载

　　3 使用应用类加载器在WEB-INF/classes中加载

　　4 使用应用类加载器在WEB-INF/lib中加载

　　5 使用common类加载器在CATALINA_HOME/lib中加载（违背双亲委派）



需要注意的是，tomcat提供了delegate属性用于控制是否启用java委派模式，默认false（不启用），当设置为true时，tomcat将使用java的默认委派模式。



## 如何在tomcat中引用同一个jar包的不同版本

一般使用自定义的类加载器

## 参考内容

[图解Tomcat类加载机制(阿里面试题)](https://www.cnblogs.com/aspirant/p/8991830.html)

[classloader实战：一个程序使用相同数据库的两个不同版本的jar包](https://my.oschina.net/xpbob/blog/774722)