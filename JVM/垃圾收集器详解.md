# 垃圾收集器学习

[toc]

## 垃圾收集器介绍

**新生代收集器：**

>  Serial
>
> ParNew
>
> Parallel Scavenge

**老年代收集器：**

> Serial Old
>
> CMS
>
> Parallel Old

新生代和老年代都可以使用：G1

**下图是各垃圾收集器之间联合使用关系，连线表示可以联合使用**

<img src="https://i.loli.net/2020/04/01/rS8qkhm3D7z6NYg.png" alt="image-20200401133348413" style="zoom:67%;" />

## Serial

**运行流程**

<img src="https://i.loli.net/2020/04/01/ar5etsyoXCqZwf8.png" alt="image-20200401133531002"  />
这个收集器是一个**单线程**工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，**更重要的是强 调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束**。

## ParNew

**运行流程**

<img src="https://i.loli.net/2020/04/01/4hWpuAEYsgjNBTO.png" alt="image-20200401133759759" style="zoom:67%;" />

**ParNew收集器实质上是Serial收集器的多线程并行版本**，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规 则、回收策略等都与Serial收集器完全一致。

**ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果**，甚至由于存在线程 交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分
之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时 系统资源的高效利用还是很有好处的。

## Parallel Scavenge

<img src="https://i.loli.net/2020/04/01/cdmQEslD6bPLwIT.png" alt="image-20200401135115339" style="zoom:80%;" />

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能 地缩短垃圾收集时用户线程的停顿时间，而**Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）**。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。

​										$$吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$$

**Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。**

-XX：MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得 系统的垃圾收集速度变得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的： 系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得 更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间 的确在下降，但吞吐量也降下来了。

-XX：GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。

**Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy**，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区 的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时 间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。**自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。**

## Serial Old

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用**标记-整理算法**。

**运行流程**

<img src="https://i.loli.net/2020/04/01/ar5etsyoXCqZwf8.png" alt="image-20200401133531002" style="zoom:80%;" />

## Parallel Old

**运行流程**

<img src="https://i.loli.net/2020/04/01/cdmQEslD6bPLwIT.png" alt="image-20200401135115339" style="zoom:80%;" />

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记-整理算法**实 现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相 当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。由于 老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上 获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处 理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一 定比ParNew加CMS的组合来得优秀。

**直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。**

## CMS

CMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器。<img src="https://i.loli.net/2020/04/01/zFpBjvXascdVIQr.png" alt="image-20200401135620554" style="zoom:80%;" />



**CMS的垃圾清理分为4步**

1. 初始标记（CMS initial mark）,要暂停用户线程
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）,要暂停用户线程
4. 并发清除（CMS concurrent sweep）,由于采用的是标记-清理算法，所以不需要移动，也就可以和用户线程并发运行

**初始标记**仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

**并发标记**阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

**重新标记**阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短

**并发清除**阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

**缺点**

1. CMS收集器对处理器资源非常敏感。

   事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量 +3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的 处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。因此提供了一种叫**增量式并发收集器**的CMS，用于在处理器核心很少的时候进行优化。

   方法就是在**并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的 时间**，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变 慢的时间更多了，但速度下降幅度就没有那么明显。

2. CMS收集器无法处理“浮动垃圾”。有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶 段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集 时再清理掉。这一部分垃圾就称为“浮动垃圾”。

3. CMS会产生大量的内存碎片。CMS是一款基于**“标记-清除”算法**实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次FullGC的情况。

## G1

   Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。

   <img src="https://i.loli.net/2020/04/01/p7qmxhDuQjSi4dM.png" alt="image-20200401141653163" style="zoom:80%;" />

**G1的里程碑设计**

在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老 年代（Major GC），再要么就是整个Java堆（Full GC）。

而G1可以面向堆内存任 何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。



**G1的主要设计**

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：**G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region）**，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。



**G1的垃圾清理**

**初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段**需要停顿线程**，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
**并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。
**最终标记**：对用户线程做另一个**短暂的暂停**，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。
**筛选回收**：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。**这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的**。

**优点**

1. 低延迟
2. 可以由用户指定期望的停顿时间，因此G1在尽可能保证低延迟的情况下还保持了高吞吐量。这个时间一般设置在100ms-300ms。但是如果设置时间过短，可能会导垃圾收集速度比不上分配速度，最后导致触发Full GC。
3. 相比于CMS，由于采用的是标记-整理算法，因此不容易产生内存碎片，也就不容易触发FUll GC，所以更加适合长时间运行。
4. **目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间**

**缺点**

由于需要维护众多Region区域的信息，每一个Region都需要维护一个记忆集，因此需要的内存是庞大的。G1至少要耗费大约相当于Java堆容量10%至20%的额 外内存来维持收集器工作。

## 低延迟垃圾处理器

<img src="https://i.loli.net/2020/04/01/XDFj3Tl5VrcyIBd.png" alt="image-20200401143829888" style="zoom:80%;" />

上述的图片，**浅色部分表示需要暂停用户线程，深色表示可以并发运行**。（PS，上图的G1个人感觉有点问题）

可以看到，虽然CMS和G1都号称低延迟处理器，但是还有多相当一部分内容运行的时候需要暂停线程。所以出现了两款新的垃圾收集器，Shenandoah和ZGC，这两个垃圾收集器，几乎整个工作过程全 部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定 的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在 ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方 夜谭、匪夷所思的目标。

具体关于这两个垃圾收集器日后分析

## 参考内容

<<深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明>>

