# 知识总结（三）

[toc]

# 操作系统部分

## 进程间通信的方式

1. 匿名管道，管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程中执行（也就是父子进程）
2. 命名管道，和匿名管道一样，唯一的区别在于允许没有亲缘关系的进程执行
3. 消息队列，消息队列是一个链表，主要用于克服管道只能承载无格式字节流以及缓冲区大小受限的缺点
4. 信号量，信号量是一个计数器，主要控制多个进程对共享内存的访问。可以用来控制不同进程间和同一进程内不同线程之间的同步机制。
5. 套接字，主要用于不同机器之间的通信。
6. 信号，主要用于通知接收进程某个事件已经发生。
7. 共享内存 ，共享内存是一块能被其他进程所访问的内存。设计原因主要是因为其他的进程通信的方式效率低下。

## 用户态和内核态的区别

内核态（Kernel Mode）：运行操作系统程序，操作硬件

用户态（User Mode）：运行用户程序

## 用户态切换到内核态的情况

1. 系统调用，fork
2. 异常，缺页中断
3. 外围设备的中断，硬盘读写

# 计网部分

## OSI七层模型和TCP/IP模型及各层的协议

ARP协议在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。

| OSI七层网络模型         | TCP/IP五层概念模型 | 对应网络协议                            |
| ----------------------- | ------------------ | --------------------------------------- |
| 应用层（Application）   | 应用层             | HTTP、DNS，FTP，POP3，SMTP              |
| 表示层（Presentation）  | 应用层             |                                         |
| 会话层（Session）       | 应用层             | SSL，TLS                                |
| 传输层（Transport）     | 传输层             | TCP, UDP                                |
| 网络层（Network）       | 网络层             | IP, ICMP, ARP, RARP, AKP, UUCP          |
| 数据链路层（Data Link） | 数据链路层         | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP |
| 物理层（Physical）      | 物理层             | IEEE 802.1A, IEEE 802.2到IEEE 802.11    |

## tracert指令

tracert是路由跟踪命令，用于确定 IP 数据包访问目标所采取的路径。基于ICMP

## ping命令

ping命令基于ICMP协议，**ICMP报文封装在ip包里**。ICMP协议也是tcp/ip协议族中的一个子协议，所以从这一层来看，icmp报文和tcp报文，udp报文是同一个级别。但是ICMP报文是属于网络层的协议的。

## DNS协议

DNS协议的传输层协议是UDP和TCP两种。这样做的主要原因是UDP和TCP的传输的数据是不同的。UDP报文的最大长度是512字节，但是速度快，而使用TCP的则可以传输的最大长度是大于512个字节的，但是速度慢。

基于以上两种原因，在使用DNS协议的时候就有不用的策略。

> 域名解析时使用TCP协议
>
> 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 
>
> 域名解析时使用UDP协议
>
> 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

## DHCP协议

基于UDP

## Redis部分

## redis的持久化机制

### rdb

rdb的持久化机制是指通过快照的方式，在指定的时间间隔内将内存中的数据集快照保存到磁盘中。

#### 触发时机

- 执行`save`和`bgsave`指令主动生动对应rdb文件
- 使用`shutdown`关闭redis时，会执行`save`指令
- 在执行主从复制的时候，当从库需要全量复制主库的文件时，主库会执行`bgsave`指令生成rdb文件，传输给从库
- 配置文件设置`save <seconds> <changes>`规则，表示在seconds秒内，至少有changes次变化，就会自动触发`gbsave`命令

#### save指令和bgsave指令

两者的区别在于执行save指令的时候，redis服务就会被阻塞，在save命令完成之前，redis服务器不能处理任何的请求。

而bgsave在执行的过程中，则是fork了一个子进程来处理生成rdb文件这个文件。子进程会把数据集先写入临时文件，写入成功之后，再替换之前的RDB文件，用二进制压缩存储，这样可以保证RDB文件始终存储的是完整的持久化内容

### aof

aof指的是append only file。意思就是会把每一条写命令添加到aof文件的末尾，用于记录数据的变化。

一般来说，并不是每有一条写命令就立马写入到aof文件中的。

redis有一个对应的`aof_buf`缓冲区，每一条命令会先暂时保存到这里。

至于何时将缓存中的数据同步到aof文件中，取决于具体的执行策略

`appendfsync always`：将`aof_buf`缓冲区的所有内容写入并同步到AOF文件，每个写命令同步写入磁盘

`appendfsync everysec`：将`aof_buf`缓存区的内容写入AOF文件，每秒同步一次，该操作由一个线程专门负责

`appendfsync no`：将`aof_buf`缓存区的内容写入AOF文件，什么时候同步由操作系统来决定

一般来说是第二种，每秒同步一次，相比于第一种，可以有效减少磁盘IO次数。


一般来说，aof保存每一条写命令，这带来的一个问题就是，随着系统的执行，aof文件会越来越大。

因此需要有一个对应的重写操作，用来压缩aof文件，减少文件的体积。

##### aof的重写

因为aof文件中的指令并不是所有的指令都是最有效的，可能会存在过期的数据指令，无效的命令（重复设置、删除）、多个命令可合并为一个命令（批处理命令）等等。

可以手动通过`bgrewriteaof`指令来重写aof文件。

**具体的执行流程**

- fork子进程用于重写aof文件

- 在重写期间，服务器进程继续处理命令请求，如果有写入的命令，追加到`aof_buf`的同时，还会追加到`aof_rewrite_buf`AOF重写缓冲区

- 当子进程完成重写之后，会给父进程一个信号，然后父进程会把AOF重写缓冲区的内容写进新的AOF临时文件中，再对新的AOF文件改名完成替换，这样可以保证新的AOF文件与当前数据库数据的一致性

### rdb和aof区别

rdb：文件内容紧凑，适合做数据的备份，性能较高，但是生成rdb文件比较耗时，且如果数据丢失，会一次丢失较多的数据

aof：数据安全性高，每次同步所需要的时间短，可用于误删紧急恢复，但是aof文件通常比较冗余，体积大，恢复速度也比rdb文件慢

# Redis部分

## Redis的底层数据结构

### SDS(简单动态字符串)

sds的数据结构很简单，分为三部分

```
struct sdshdr{
	int len;
	int free;
	char buf[];
}
```

len字段标识当前字符串的长度

free字段标识数组中未使用的字节数量

buf数组用于保存字符串的内容

**之所以不适用c语言自带的char数组，而是自己封装了一层，主要是基于以下的原因**

1. c语言要获取字符串的长度需要遍历数组，时间复杂度会达到O（N），那么这个时间复杂度会影响Redis的性能，所以通过添加一个len字段来O（1） 的获得数组长度

2. 由于c的字符串没有防止内存溢出的措施，就导致如果没有提前分配好空间就会导致错误。因此，sds设置了free字段用于保存可用字节数量，每次添加字符的时候，会先判断空间是不是够用，如果不够用，则会先扩容。

   这里当字节小于1MB的时候，每次free相同的大小，如果大于1MB，则是每次free的空间大小固定为1MB。

3.  sds的free字段还可以用于减少内存重分配的次数，每次多分配一些空间，可以有效减少小范围的内存重分配。

4. sds还可以保存非文本数据。由于c的字符串固定已‘0’为结尾，导致用c字符串保存文件，图片等二进制数据的时候，中间如果有‘0’字符，就会出错。

### 链表

链表是比较常见的数据结构了，Redis的链表也差不多。Redis的链表是一个双向链表，每一个节点即是listNode。

链表用list进行封装，有head标识双向链表的头节点，tail标识尾节点，len标识链表长度，dup是复制函数，free是释放节点函数，match是比较函数。其中链表是用多态实现的，满足了各种数据结构的要求。

```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
```

```c
typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```

### 字典

Redis的字典的底层是通过哈希表来实现的。

```c
//字典定义
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; 
    unsigned long iterators;
} dict;
```

```c
//哈希表定义
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;

```

```c
//哈希表节点定义
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;

```

**一个哈希表的图**

![image-20200914113133540](https://i.loli.net/2020/09/14/8jurIfV2At4JRC3.png)

**一个字典的图**

![image-20200915092105724](https://i.loli.net/2020/09/15/Z93Lr4128bxuoJD.png)

字典的底层结构其实就是哈希表，而哈希表就一定会有哈希冲突的问题。

这里解决这个问题的方案就是采用链地址法。需要注意的是，这里采用的是头插法来添加节点，这么做的原因在于无法知道链表的长度，所以采用头插法可以O(1)的解决冲突的问题。

哈希表的另外一个问题就是哈希表的扩容和收缩的问题。

在Redis中，哈希表的扩容主要由两方面决定，一是负载因子的大小，二是是否执行`BGSAVE`和`BGREWRITEAOF`命令。

> ​	服务器没有执行`BGSAVE`和`BGREWRITEAOF`命令，且负载因子大于等于1，执行扩容
>
> ​	服务器正在执行`BGSAVE`和`BGREWRITEAOF`命令，且负载因子大于等于5，执行扩容
>
> ​	当负载因子小于0.1 ，执行收缩
>
> ​	负载因子 = 哈希表已经保存节点的数量/哈希表的大小

**对于在执行`BGSAVE`和`BGREWRITEAOF`时，提高阈值的解释**

 因为上述的两条指令的基本原理是调用fork()函数。那么linux在fork的时候会用到一种COW(CopyOnWrite)的技术

> fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。
>
> CopyOnWrite的好处：
> 1、减少分配和复制资源时带来的瞬时延迟；
> 2、减少不必要的资源分配；
> CopyOnWrite的缺点：
> 1、如果父子进程都需要进行大量的写操作，会产生大量的分页错误（页异常中断page-fault）;
>
>  **Redis中的CopyOnWrite**
>
> - Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那**Redis会fork出一个子进程来读取数据，从而写到磁盘中**。
> - 总体来看，**Redis还是读操作比较多**。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的**分页错误(页异常中断page-fault)**，这样就得耗费不少性能在复制上。
> - 而在**rehash阶段上，写操作是无法避免**的。所以Redis在fork出子进程之后，**将负载因子阈值提高，尽量减少写操作**，避免不必要的内存写入操作，最大限度地节约内存。

但是，我们知道在rehash的过程中必然会存在大量的写操作，所以如果在执行`BGSAVE`和`BGREWRITEAOF`的时候发生了rehash，那么执行效率会非常低。为了解决这个问题，采用的策略就是提高rehash的阈值，避免在fork的时候发生rehash。

#### 渐进式rehash

在redis的哈希表发生的rehash并不是立马就执行完毕的。因为如果哈希表中有太多的内容的话，一次扩容就会占用很大的时间，造成redis性能的损失。所以一般采用渐进式rehash来解决这个问题。渐进式rehash指的rehash过程不一步到位，在添加，删除，查找过程中一步步执行。主要通过保存rehashidx字段来控制进行到哪一个索引了。

由于字典存在两个哈希表，ht[0]和ht[1]。每次扩容就是利用另外一个来保存数据的。假设使用的是ht[0]，利用扩容的是ht[1]

那么所有的添加操作都是针对新的ht[1],旧的ht[0]都只是作为配合查询使用。

具体细节可以参考《redis设计与实现》

### 跳表

跳表的数据结构如下

![image-20200924225803257](https://i.loli.net/2020/09/24/utkfiVA5xsdq4Kv.png)

跳表从某种意义上来说可以算是允许二分的链表，通过增加每一层的跨度，加快查询的速度。

