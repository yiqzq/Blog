# Redis 面试

[toc]



## 1. 如果有大量的key需要设置同一时间过期，一般需要注意什么？

如果大量的key过期时间设置的过于集中，到过期的那个时间点，**Redis**可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。

## 2 Redis的分布式锁

### 2.1 单机环境下

一般采用`setnx+lua`脚本的方式实现,或者是使用`set key value px milliseconds nx`的指令来实现。

这样方式的核心点在于以下

1. set命令要用`set key value px milliseconds nx`；
2. value要具有唯一性；（可以采用UUID+threadId）
3. 释放锁时要验证value值，不能误解锁；

### 2.2 分布式环境下

单机环境下的方案放到分布式的环境下是不可行的。原因在于可能存在锁丢失的情况。

当加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：

1. 在Redis的master节点上拿到了锁；
2. 但是这个加锁的key还没有同步到slave节点；
3. master故障，发生故障转移，slave节点升级为master节点；
4. 导致锁丢失。

Redis作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：**Redlock**。

**Redlock实现**

在Redis的分布式环境中，我们假设有N个Redis master。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。

为了取到锁，客户端应该执行以下操作:

- 获取当前Unix时间，以毫秒为单位。
- 依次尝试从5个实例，使用相同的key和**具有唯一性的value**（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
- 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。**当且仅当从大多数**（N/2+1，这里是3个节点）**的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**。
- 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
- 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。

## 3 Redis提供服务时使用keys指令带来的问题

由于Redis是单线程的，使用keys指令可能带来阻塞。如果数据库内容过于庞大，可能会延迟数秒之久，直到指令执行完毕，服务才能恢复。

**解决方法可以采用scan指令。**

相比于keys命令，scan命令有两个比较明显的优势：

1. scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。
2. scan命令提供了limit参数，可以控制每次返回结果的最大条数。

scan指令也是有缺点的，就是肯可能返回重复的数据，这个就需要程序自己控制去重了。

## 4 Redis实现异步队列

**方式一：生产者消费者模式**
使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。
或者，不用sleep，直接用blpop指令，在没有消息的时候，它会阻塞住直到消息到来。

**方式二：发布订阅者模式**
使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

缺点：在消费者下线的情况下，生产的消息会丢失。此场景，建议用MQ。

**延时队列**

使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒之前的数据轮询进行处理。

## 5 Redis的缓存淘汰策略

- **allkeys-lru**：从所有key中使用LRU算法进行淘汰
- **volatile-lru**：从设置了过期时间的key中使用LRU算法进行淘汰

- **allkeys-random**：从所有key中随机淘汰数据

- **volatile-random**：从设置了过期时间的key中随机淘汰

- **volatile-ttl**：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰
- **noeviction(默认策略)**：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）

在控制台可以通过`config get maxmemory-policy`命令来查看策略

## 6 Redis和Memcache 的比较

**数据类型**
Redis支持的数据类型要丰富得多，Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List，Set，Hash，Sorted Set，pub/sub，Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已。memcache支持简单数据类型，需要客户端自己处理复杂对象 
**持久性**
redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。memcache不支持数据持久存储 

**分布式存储**
redis支持master-slave复制模式。

memcache可以使用一致性hash做分布式。

**value大小不同**
memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用

**数据一致性不同**

Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。

## 7 Redis数据类型简单应用

### **String**

- **缓存功能：String**字符串是最常用的数据类型，不仅仅是**Redis**，各个语言都是最基本类型，因此，利用**Redis**作为缓存，配合其它数据库作为存储层，利用**Redis**支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。
- **计数器：**许多系统都会使用**Redis**作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。
- **共享用户Session：**用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存**Cookie**，但是可以利用**Redis**将用户的**Session**集中管理，在这种模式只需要保证**Redis**的高可用，每次用户**Session**的更新和获取都可以快速完成。大大提高效率。

### **Hash**

一般对象如果不想序列化，就可以使用Hah来存储。

Redis的Hash实际是内部存储的Value为一个HashMap，也就是说，Key仍然是用户ID,value是一个Map，这个Map的key是成员的属性名，value是属性值。

### **List**

- **消息队列：Redis**的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过**Lpush**命令从左边插入数据，多个数据消费者，可以使用**BRpop**命令阻塞的“抢”列表尾部的数据。
- 文章列表或者数据分页展示的应用。

### **Set**

**Set** 是无序集合，会自动去重。Set的一大功能就是可以使用交集并集差集，那就可以使用这个功能做一些比如共同好友之类的功能。

### **Zset**

Zset是可以排序的set。相比于set，多了一个分数，然后就可以根据分数来排序。

- 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。

### **BitMap**

bitmap中文意思就是位图，使用的是二进制来表示一位。

- 布隆过滤器
- 统计用户在线状态

### **HyperLogLog**

这个数据类型很神奇，下面说一下他的由来。

**现在有一个问题，有一个页面，需要统计有多少用户访问了该页面，重复的用户只能算一次。**

在数据量较小的情况下，可以使用HashMap，使用String 作为key，使用一个boolean的值表示是否访问量。这样，占用的空间就取决于用户数。如果用户规模达到百万，则这种占用内存过大，不行。

除此之外，还有可以使用bitmap来处理，如果需要统计1亿的数据，也只需要100000000/8/1024/1024 ≈ 12M的空间，但是这是统计一个对象数据的，如果有多个，比如说10000个，也差不多需要120G的空间，在大数据下，同样不行。

基于上述的问题，有了**HyperLogLog**这一神奇的结构，这个结构主要提供不精确的去重计数功能，因为是依赖于概率论的数学结论。根据官方的说法，**在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。**

HyperLogLog主要在基数足够大，且允许有一定误差的情况下统计。

- 统计注册 IP数
- 统计在线用户数

### **Geospatial**

可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。

- 附近的人之类的应用

## 8 持久化机制

### RDB

RDB其实就是把数据以快照的形式保存在磁盘上，快照可以理解成把当前时刻的数据拍成一张照片保存下来。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。

**对于RDB来说，提供了三种机制：save、bgsave、自动化。**

**save触发方式**

该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。

**bgsave触发方式**

执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。

具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。

**自动触发**

自动触发是由我们的配置文件来完成的。在redis.conf配置文件中。

**优点**

1. RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。
2. 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
3. RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

**缺点**

1. 当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，**可能丢失数据**。

2. 当数据比较大的时候，比较耗时

### AOF

以日志的形式来记录每个写操作，将`Redis`执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件。

**文件重写原理**

AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。

重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

**同步方式**

**每修改同步always：**

同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好

**每秒同步everysec：**

异步操作，每秒记录 如果一秒内宕机，有数据丢失

**不同no：**

从不同步

**优点**

1. AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。
2. AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损
3. AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
4. AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据

**缺点**

1. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大
2. ）AOF开启后，根据使用的fsync策略，支持的写QPS会比RDB支持的写QPS低。

### **两者比较**

<img src="https://i.loli.net/2020/07/02/6ot48IHaAmLjBTi.jpg" style="zoom:80%;" />

## 9 哨兵机制

哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并**不能保证数据不丢失**，但是可以保证集群的**高可用**。

**主要功能**

- **监控（Monitoring）**： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- **提醒（Notification）**： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知
- **自动故障迁移（Automatic failover）**： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。

## 10 主从模式

主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

**主从复制的作用**

主从复制的作用主要包括：

1. **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2. **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
3. **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
4. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## 11 集群

Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施。**为了解决单机Redis容量有限的问题**，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。

Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中//有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。

Redis 集群提供了以下两个好处：

- 将数据自动切分（split）到多个节点的能力。
- 当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。

 **数据分片**

Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。

## **12 缓存常见问题**

### 缓存雪崩

缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。

**主要使用以下的三种手段**

1. 使用集群缓存，保证缓存服务的高可用
2. ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死
3. 开启Redis持久化机制，尽快恢复缓存集群

- 缓存过期时间设置一个随机值，避免同时过期
- redis分布式部署，将热点数据分布在不同的服务器上
- 热点数据不过期
- 设置二级缓存

### 缓存穿透

请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为**缓存穿透**。

1. 缓存空值
2. 布隆过滤器
3. 接口层做数据的校验，拦截一部分非法请求，比如id<0


### 缓存击穿

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为**缓存击穿**。

1. 使用互斥锁
2. 考虑热点数据不过期

## 参考资料

[Redlock：Redis分布式锁最牛逼的实现](https://mp.weixin.qq.com/s?__biz=MzU5ODUwNzY1Nw==&mid=2247484155&idx=1&sn=0c73f45f2f641ba0bf4399f57170ac9b&scene=21#wechat_redirect)

[《我们一起进大厂》系列- Redis基础](https://juejin.im/post/5db66ed9e51d452a2f15d833)

